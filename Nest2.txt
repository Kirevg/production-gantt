Пошаговая логика работы этапов работ в канбане (с момента загрузки страницы)
ШАГ 1: Загрузка страницы браузером
1.1. Пользователь открывает страницу "Канбан" (например, через навигацию в App.tsx)
1.2. React создает экземпляр компонента KanbanBoard
1.3. Компонент KanbanBoard получает пропсы (если есть)
ШАГ 2: Инициализация компонента KanbanBoard
2.1. Создаются состояния:
kanbanTasks — глобальный массив всех задач (проекты, изделия, этапы)
productStagesMap — Map для этапов каждого изделия (ключ: productId, значение: массив этапов)
2.2. Загружаются настройки из localStorage:
Свернутые проекты (collapsedProjects)
Свернутые изделия (collapsedProducts)
Фильтры статусов (statusFilters)
2.3. Настраиваются сенсоры для drag-and-drop:
ШАГ 3: Первый useEffect — загрузка данных при монтировании
3.1. Выполняется useEffect:
3.2. Вызывается fetchKanbanData() для загрузки данных
ШАГ 4: Функция fetchKanbanData() — запрос к API
4.1. Внутри fetchKanbanData():
4.2. Формируется HTTP-запрос:
4.3. Отправка запроса на сервер
ШАГ 5: API обрабатывает запрос (на сервере)
5.1. API эндпоинт: GET /projects/gantt
5.2. Prisma запрос:
5.3. Сервер возвращает JSON-массив всех этапов работ со связанными данными (проекты, изделия, исполнители, виды работ)
ШАГ 6: Обработка ответа от API
6.1. Получение ответа:
6.2. Преобразование данных в формат KanbanTask[]:
6.3. Обновление глобального состояния:
ШАГ 7: Создание локального состояния для этапов каждого изделия
7.1. Создание Map для группировки этапов по изделиям:
7.2. Сортировка этапов каждого изделия по orderIndex:
7.3. Сохранение в локальное состояние:
Пример структуры:
ШАГ 8: React перерисовывает компонент
8.1. После setKanbanTasks(tasks) и setProductStagesMap(stagesMap) React видит изменения состояний
8.2. Компонент перерисовывается с новыми данными
8.3. Начинается рендеринг иерархии: Проекты → Изделия → Этапы
ШАГ 9: Группировка данных для отображения
9.1. Группировка задач по проектам:
9.2. Сортировка проектов по projectOrderIndex:
ШАГ 10: Группировка этапов по изделиям внутри проекта
10.1. Для каждого проекта группируются задачи по изделиям:
10.2. Сортировка изделий по productOrderIndex:
ШАГ 11: Получение этапов для отображения
11.1. Для каждого изделия этапы берутся из productStagesMap:
Порядок берется из локального состояния, не из фильтрации productTasks
11.2. Проверка наличия этапов:
ШАГ 12: Создание SortableContext для этапов
12.1. Создается SortableContext:
12.2. items — массив ID этапов в текущем порядке из productStagesMap
ШАГ 13: Рендер карточек этапов
13.1. Рендерятся карточки этапов:
13.2. Для каждого этапа создается SortableStageCard:
key={task.id} — React использует ID как ключ
Порядок берется из массива actualStages из productStagesMap
ШАГ 14: Инициализация SortableStageCard
14.1. Для каждой карточки вызывается useSortable:
14.2. dnd-kit регистрирует элемент как перетаскиваемый
14.3. Применяются стили:
ШАГ 15: Готово к использованию
15.1. Страница загружена
15.2. Этапы отображаются в карточках изделий в порядке из базы данных
15.3. Каждый этап можно перетаскивать
ШАГ 16: Перетаскивание этапа (когда пользователь перетаскивает)
16.1. Пользователь начинает перетаскивание:
Нажимает на карточку этапа
Перемещает мышь
16.2. PointerSensor отслеживает движение (активация после 8px)
16.3. Применяется transform для визуального перемещения карточки
16.4. При отпускании вызывается handleDragEnd
ШАГ 17: handleDragEnd — обработка перетаскивания
17.1. Получение active и over:
17.2. Поиск задач в глобальном массиве:
17.3. Проверка принадлежности одному изделию:
17.4. Получение этапов из локального состояния:
17.5. Поиск индексов в массиве этапов этого изделия:
17.6. Перестановка в массиве:
17.7. Обновление orderIndex:
ШАГ 18: Обновление состояния для анимации
18.1. Обновление локального состояния:
18.2. Обновление глобального массива для синхронизации:
ШАГ 19: React перерисовывает с новым порядком
19.1. После setProductStagesMap(newProductStagesMap) React видит изменение
19.2. actualStages пересчитывается из productStagesMap.get(productKey)
19.3. stagesKey меняется (потому что orderIndex изменился)
19.4. SortableContext получает новый ключ и пересоздается
19.5. actualStages.map() создает новый массив элементов в новом порядке
19.6. React сравнивает элементы по key={task.id} и перемещает их в DOM
19.7. dnd-kit применяет анимацию через transition
ШАГ 20: Сохранение на сервер
20.1. Через 300ms (после завершения анимации) выполняется setTimeout:
20.2. Формирование данных для API:
20.3. Отправка запроса:
20.4. Логирование в консоль:
20.5. Сервер обновляет orderIndex в базе данных
20.6. При успехе:
20.7. При ошибке — откат через fetchKanbanData():
Итоговая последовательность при перетаскивании:
Пользователь перетаскивает этап → dnd-kit отслеживает движение
При отпускании → вызывается handleDragEnd
Находятся oldIndex и newIndex в массиве productStages из productStagesMap
arrayMove(productStages, oldIndex, newIndex) → новый массив с переставленными элементами
Обновляется orderIndex для всех этапов
setProductStagesMap(newProductStagesMap) → обновление локального состояния
setKanbanTasks(...) → синхронизация глобального массива
React перерисовывает → actualStages пересчитывается из productStagesMap
SortableContext получает новый ключ и пересоздается
Элементы меняют позиции в DOM
dnd-kit применяет анимацию
Через 300ms отправляется запрос на сервер для сохранения нового порядка
При ошибке — откат через fetchKanbanData()
Ключевое отличие от ProductCard: в канбане используется productStagesMap (Map для всех изделий), а в ProductCard — локальный массив stages для одного изделия. Логика работы идентична.