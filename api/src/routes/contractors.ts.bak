import express from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma';
import { authenticateToken, requireRole } from '../middleware/auth';

const router = express.Router();

// Схема валидации для создания исполнителя
const createContractorSchema = z.object({
    name: z.string().min(1, 'Название обязательно'),
    contactName: z.string().min(1, 'Контактное лицо обязательно'),
    phone: z.string().min(1, 'Телефон обязателен'),
    email: z.string().email().optional().or(z.literal('')),
    isActive: z.boolean().default(true)
});

// Схема валидации для обновления исполнителя
const updateContractorSchema = z.object({
    name: z.string().min(1, 'Название обязательно').optional(),
    contactName: z.string().min(1, 'Контактное лицо обязательно').optional(),
    phone: z.string().min(1, 'Телефон обязателен').optional(),
    email: z.string().email().optional().or(z.literal('')),
    isActive: z.boolean().optional()
});

// GET /contractors - получить всех исполнителей
router.get('/', authenticateToken, async (req, res) => {
    try {
        const contractors = await prisma.contractor.findMany({
            orderBy: [
                { name: 'asc' }
            ]
        });

        res.json(contractors);
    } catch (error) {
        console.error('Ошибка получения исполнителей:', error);
        res.status(500).json({ error: 'Ошибка получения исполнителей' });
    }
});

// GET /contractors/:id - получить исполнителя по ID
router.get('/:id', authenticateToken, async (req, res) => {
    try {
        const { id } = req.params;

        if (!id) {
            return res.status(400).json({ error: 'Contractor ID is required' });
        }

        const contractor = await prisma.contractor.findUnique({
            where: { id }
        });

        if (!contractor) {
            return res.status(404).json({ error: 'Исполнитель не найден' });
        }

        res.json(contractor);
    } catch (error) {
        console.error('Ошибка получения исполнителя:', error);
        res.status(500).json({ error: 'Ошибка получения исполнителя' });
    }
});

// POST /contractors - создать исполнителя (только для админов и менеджеров)
router.post('/', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
    try {
        const data = createContractorSchema.parse(req.body);

        // Проверяем уникальность email, если он указан
        if (data.email && data.email !== '') {
            const existingContractor = await prisma.contractor.findFirst({
                where: { email: data.email }
            });

            if (existingContractor) {
                return res.status(400).json({ error: 'Исполнитель с таким email уже существует' });
            }
        }

        const contractor = await prisma.contractor.create({
            data: {
                name: data.name,
                contactName: data.contactName,
                phone: data.phone,
                email: data.email && data.email !== '' ? data.email : null,
                isActive: data.isActive
            }
        });

        res.status(201).json(contractor);
    } catch (error) {
        if (error instanceof z.ZodError) {
            return res.status(400).json({ error: 'Неверные данные', details: error.issues });
        }
        console.error('Ошибка создания исполнителя:', error);
        res.status(500).json({ error: 'Ошибка создания исполнителя' });
    }
});

// PUT /contractors/:id - обновить исполнителя (только для админов и менеджеров)
router.put('/:id', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
    try {
        const { id } = req.params;
        const data = updateContractorSchema.parse(req.body);

        if (!id) {
            return res.status(400).json({ error: 'Contractor ID is required' });
        }

        // Проверяем, что исполнитель существует
        const existingContractor = await prisma.contractor.findUnique({
            where: { id }
        });

        if (!existingContractor) {
            return res.status(404).json({ error: 'Исполнитель не найден' });
        }

        // Проверяем уникальность email, если он указан и изменился
        if (data.email && data.email !== '' && data.email !== existingContractor.email) {
            const emailExists = await prisma.contractor.findFirst({
                where: { email: data.email }
            });

            if (emailExists) {
                return res.status(400).json({ error: 'Исполнитель с таким email уже существует' });
            }
        }

        const contractor = await prisma.contractor.update({
            where: { id },
            data: {
                ...(data.name && { name: data.name }),
                ...(data.contactName && { contactName: data.contactName }),
                ...(data.phone && { phone: data.phone }),
                ...(data.email !== undefined && { email: data.email && data.email !== '' ? data.email : null }),
                ...(data.isActive !== undefined && { isActive: data.isActive })
            }
        });

        res.json(contractor);
    } catch (error) {
        if (error instanceof z.ZodError) {
            return res.status(400).json({ error: 'Неверные данные', details: error.issues });
        }
        console.error('Ошибка обновления исполнителя:', error);
        res.status(500).json({ error: 'Ошибка обновления исполнителя' });
    }
});

// DELETE /contractors/:id - удалить исполнителя (только для админов)
router.delete('/:id', authenticateToken, requireRole(['admin']), async (req, res) => {
    try {
        const { id } = req.params;

        if (!id) {
            return res.status(400).json({ error: 'Contractor ID is required' });
        }

        // Проверяем, что исполнитель существует
        const existingContractor = await prisma.contractor.findUnique({
            where: { id }
        });

        if (!existingContractor) {
            return res.status(404).json({ error: 'Исполнитель не найден' });
        }

        await prisma.contractor.delete({
            where: { id }
        });

        res.json({ message: 'Исполнитель удален' });
    } catch (error) {
        console.error('Ошибка удаления исполнителя:', error);
        res.status(500).json({ error: 'Ошибка удаления исполнителя' });
    }
});

export default router;
